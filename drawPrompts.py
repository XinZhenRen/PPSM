import random
import cv2
import os
import numpy as np
import progressbar
#SAM-Prompts are generated by SAM and subject to specific filtering

def find_max_distance_points(contour):
    max_distance = 0
    max_distance_point1 = None
    max_distance_point2 = None

    for i in range(len(contour)):
        for j in range(i + 1, len(contour)):
            distance = np.linalg.norm(contour[i] - contour[j])
            if distance > max_distance:
                max_distance = distance
                max_distance_point1 = tuple(contour[i][0])
                max_distance_point2 = tuple(contour[j][0])

    return max_distance_point1, max_distance_point2
def find_centroid_and_contour(binary_image):
    contours, _ = cv2.findContours(binary_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    centroids = []
    polygon_coords = []
    boundary_coords = []
    max_distance_points = []
    curve_coeffs = []
    if len(contours) > 0:
        contour = max(contours, key=cv2.contourArea)
        M = cv2.moments(contour)
        if M["m00"] != 0:
            cx = int(M["m10"] / M["m00"])
            cy = int(M["m01"] / M["m00"])
            centroids.append((cx, cy))
            curve_points = np.vstack(contour)

        # 获取多边形的顶点坐标
        epsilon = 0.02 * cv2.arcLength(contour, True)
        polygon = cv2.approxPolyDP(contour, epsilon, True)
        polygon_coords.append(polygon)

        # 获取边界的顶点坐标
        for point in contour:
            boundary_coords.append((point[0][0], point[0][1]))

        return centroids, polygon_coords, boundary_coords, contour
    else:
        return -1, -1, -1, -1

def draw_circle(image, center, radius=30, color=(255, 255, 255), thickness=-1):
    cv2.circle(image, center, radius, color, thickness)

def draw_polygon(image, polygon_coords, color=(255, 255, 255)):
    cv2.drawContours(image, polygon_coords, -1, color, thickness=cv2.FILLED)

def draw_boundary(image, boundary_coords, color=(255, 255, 255), thickness=1):
    for point in boundary_coords:
        cv2.circle(image, (point[0], point[1]), radius=thickness,color=color,thickness=-1)

def draw_lines(image, centroid, ratio ,color_in=(255, 255, 255), color_out=(255, 255, 255), thickness=3):
    h, w = image.shape[:2]

    # 计算线的长度
    line_length = int(ratio * min(h, w))
    #
    # # 在连通域内画一条二次曲线
    # curve_in = np.array([
    #     [centroid[0] - line_length // 2, centroid[1]],
    #     [centroid[0], centroid[1] - line_length],
    #     [centroid[0] + line_length // 2, centroid[1]]
    # ], dtype=np.int32)
    # curve_in = curve_in.reshape((-1, 1, 2))
    # cv2.polylines(image, [curve_in], isClosed=False, color=color_in, thickness=thickness)
    #
    # # 在连通域外画一条二次曲线
    # curve_out = np.array([
    #     [centroid[0] - w // 2 - line_length // 2, centroid[1]],
    #     [centroid[0] - w // 2, centroid[1] - line_length],
    #     [centroid[0] - w // 2 + line_length // 2, centroid[1]]
    # ], dtype=np.int32)
    # curve_out = curve_out.reshape((-1, 1, 2))
    # cv2.polylines(image, [curve_out], isClosed=False, color=color_out, thickness=thickness)

    # 计算线的方向，可以是直线也可以是二次曲线
    #direction = np.random.choice(['line', 'quadratic'])
    direction='quadratic'
    while True:
        try:
            a=random.randint(1,15)
            # 在连通域内画一条线
            if direction == 'line':
                line_points_in = (
                    (centroid[0] - line_length // 2, centroid[1]),
                    (centroid[0] + line_length // 2, centroid[1])
                )
            else:  # 'quadratic'
                x = np.linspace(-line_length // 2, line_length // 2, line_length)
                y = -(x ** 2) / (4 * (line_length //a ) ** 2) + centroid[1]
                line_points_in = [(int(x[i] + centroid[0]), int(y[i])) for i in range(line_length)]
            cv2.polylines(image, [np.array(line_points_in)], isClosed=False, color=color_in, thickness=thickness)
            break
        except Exception as e:
            # 捕捉异常并进行处理，例如打印错误信息
            print(f"An error occurred: {e}")





    # 在连通域外画一条线
    # if direction == 'line':
    #     line_points_out = (
    #         (0, 0),
    #         (w, h)
    #     )
    # else:  # 'quadratic'
    #     x = np.linspace(0, w, w)
    #     y = -(x ** 2) / (4 * (w // 2) ** 2) + h
    #     line_points_out = [(int(x[i]), int(y[i])) for i in range(w)]
    #
    # cv2.polylines(image, [np.array(line_points_out)], isClosed=False, color=color_out, thickness=thickness)

def create_blank_image(shape):
    return np.zeros(shape, dtype=np.uint8)
def draw_ExternalCurve(image,contour):
    # 拟合曲线
    curve = cv2.fitEllipse(contour)

    # 绘制曲线
    cv2.ellipse(image, curve, (255, 255, 255), 2)  # 白色曲线
def process_image(input_path, output_folder):
    image = cv2.imread(input_path, cv2.IMREAD_GRAYSCALE)
    # height, width, channels = image.shape
    # print(channels)
    # cv2.imshow("1",image)
    # cv2.waitKey(0)

    centroids, polygon_coords, boundary_coords,contour = find_centroid_and_contour(image)

    # 创建四(五)个新的同样大小的黑色图像
    circle_blank_image = create_blank_image(image.shape)
    polygon_blank_image = create_blank_image(image.shape)
    boundary_blank_image = create_blank_image(image.shape)
    lines_blank_image = create_blank_image(image.shape)
    ExternalCurve_blank_image= create_blank_image(image.shape)

    if centroids!=-1:
        # 在新图像上画圆
        for centroid in centroids:
            draw_circle(circle_blank_image, centroid)

        # 在另一个新图像上画实心多边形
        draw_polygon(polygon_blank_image, polygon_coords)

        # 在第三个新图像上画边界
        # cv2.drawContours(boundary_blank_image, contour, -1, (255, 255, 255), 3)
        draw_boundary(boundary_blank_image, boundary_coords)

        # 在第四个新图像上画线
        for centroid in centroids:
            # 计算连通域和非连通域的面积比例
            area_ratio = cv2.contourArea(polygon_coords[centroids.index(centroid)]) / (image.shape[0] * image.shape[1])

            # 画线
            draw_lines(lines_blank_image, centroid, area_ratio)

        # 在第五个新图像上外接曲线
        draw_ExternalCurve(ExternalCurve_blank_image, contour)
    #print(os.path.join(output_folder, "Point", os.path.splitext(os.path.basename(input_path))[0]+".png"))

    # 保存结果图像
    cv2.imwrite(os.path.join(output_folder, "Point", os.path.splitext(os.path.basename(input_path))[0]+".png"), circle_blank_image)
    cv2.imwrite(os.path.join(output_folder, "Polygon", os.path.splitext(os.path.basename(input_path))[0]+".png"), polygon_blank_image)
    cv2.imwrite(os.path.join(output_folder, "Edge", os.path.splitext(os.path.basename(input_path))[0]+".png"), boundary_blank_image)
    cv2.imwrite(os.path.join(output_folder, "Scribble", os.path.splitext(os.path.basename(input_path))[0]+".png"), lines_blank_image)
    cv2.imwrite(os.path.join(output_folder, "ExternalCurve", os.path.splitext(os.path.basename(input_path))[0] + ".png"),ExternalCurve_blank_image)


if __name__ == "__main__":


    input_folder = "S:\\PyTorch\\PPSN-main\\CVC-ClinicDB\\Ground Truth\\"
    output_folder = "S:\\PyTorch\\PPSN-main\\CVC-ClinicDB\\"
    input_folder = "S:\\PyTorch\\PPSN-main\\kvasir-seg\\masks\\"
    output_folder = "S:\\PyTorch\\PPSN-main\\kvasir-seg\\"

    input_folder = "S:\\PyTorch\\PPSN-main\\hyper-kvasir\\segmented-images\\masks\\"
    output_folder = "S:\\PyTorch\\PPSN-main\\hyper-kvasir\\segmented-images\\"


    input_folder = "D:\\SHU\PyTorch\\polyp segmentation dataset\\PolypGen2021_MultiCenterData_v3\\PolypGen2021_MultiCenterData_v3\\maskC1-C6\\"
    output_folder = "D:\\SHU\PyTorch\\polyp segmentation dataset\\PolypGen2021_MultiCenterData_v3\\PolypGen2021_MultiCenterData_v3\\"

    input_folder = "D:\\SHU\PyTorch\\polyp segmentation dataset\\PolypGen2021_MultiCenterData_v3\\PolypGen2021_MultiCenterData_v3\\imagesAll_mask\\"
    output_folder = "D:\\SHU\PyTorch\\polyp segmentation dataset\\PolypGen2021_MultiCenterData_v3\\PolypGen2021_MultiCenterData_v3\\"

    input_folder = "./SUN/GT/"
    output_folder = "./SUN/"

    if not os.path.exists(os.path.join(output_folder, "Point")):
        os.makedirs(os.path.join(output_folder, "Point"))

    if not os.path.exists(os.path.join(output_folder, "Polygon")):
        os.makedirs(os.path.join(output_folder, "Polygon"))

    if not os.path.exists(os.path.join(output_folder, "Edge")):
        os.makedirs(os.path.join(output_folder, "Edge"))

    if not os.path.exists(os.path.join(output_folder, "Scribble")):
        os.makedirs(os.path.join(output_folder, "Scribble"))

    if not os.path.exists(os.path.join(output_folder, "ExternalCurve")):
        os.makedirs(os.path.join(output_folder, "ExternalCurve"))


    bar = progressbar.ProgressBar(widgets=[progressbar.Timer(),
                                           progressbar.Percentage(),
                                           ' (', progressbar.SimpleProgress(), ') ',
                                           ' (', progressbar.ETA(), ') ',
                                           ' (', progressbar.AbsoluteETA(), ') '])

    bar.start()
    file_count = 0
    for root, dirs, files in os.walk(input_folder):
        for filename in files:
            if filename.endswith(".png") or filename.endswith(".jpg") or filename.endswith(".tif") :
                input_path = os.path.join(root, filename)
                process_image(input_path, output_folder)
            file_count+=1
            bar.update(file_count)
    bar.finish()